[
  {
    "id": "github-actions-sast",
    "title": "SAST Integration with GitHub Actions",
    "description": "GitHub Actions workflow for static application security testing using CodeQL to scan code for vulnerabilities.",
    "category": "GitHub Actions Workflows",
    "code": "name: CodeQL Analysis\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n  schedule:\n    - cron: '30 1 * * 0'\n\njobs:\n  analyze:\n    name: Analyze\n    runs-on: ubuntu-latest\n    permissions:\n      actions: read\n      contents: read\n      security-events: write\n\n    strategy:\n      fail-fast: false\n      matrix:\n        language: [ 'javascript', 'python' ]\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v4\n\n    - name: Initialize CodeQL\n      uses: github/codeql-action/init@v3\n      with:\n        languages: ${{ matrix.language }}\n\n    - name: Autobuild\n      uses: github/codeql-action/autobuild@v3\n\n    - name: Perform CodeQL Analysis\n      uses: github/codeql-action/analyze@v3\n      with:\n        category: \"/language:${{matrix.language}}\"",
    "usage": "1. Create a .github/workflows/codeql-analysis.yml file in your repository\n2. Customize the branches and languages according to your project\n3. Push to trigger the workflow automatically\n4. View results in the Security tab of your GitHub repository",
    "tags": ["SAST", "CodeQL", "GitHub Actions", "Security Scanning"],
    "language": "yaml"
  },
  {
    "id": "github-container-scanning",
    "title": "Container Image Scanning Workflow",
    "description": "GitHub Actions workflow to scan Docker images for vulnerabilities using Trivy before pushing to registry.",
    "category": "GitHub Actions Workflows",
    "code": "name: Container Security Scan\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  scan-image:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v3\n\n    - name: Build Docker image\n      uses: docker/build-push-action@v5\n      with:\n        context: .\n        load: true\n        tags: app:test\n\n    - name: Run Trivy vulnerability scanner\n      uses: aquasecurity/trivy-action@master\n      with:\n        image-ref: 'app:test'\n        format: 'sarif'\n        output: 'trivy-results.sarif'\n\n    - name: Upload Trivy scan results to GitHub Security tab\n      uses: github/codeql-action/upload-sarif@v3\n      with:\n        sarif_file: 'trivy-results.sarif'",
    "usage": "1. Place this workflow in .github/workflows/container-scan.yml\n2. Ensure your Dockerfile is in the repository root\n3. The workflow will automatically scan on pushes and PRs\n4. Critical vulnerabilities will fail the build",
    "tags": ["Container Security", "Trivy", "Docker", "Vulnerability Scanning"],
    "language": "yaml"
  },
  {
    "id": "gitlab-dependency-scanning",
    "title": "Dependency Scanning with GitLab CI",
    "description": "GitLab CI template for automated dependency vulnerability scanning using various tools based on project type.",
    "category": "GitLab CI Templates",
    "code": "stages:\n  - test\n\ninclude:\n  - template: Security/Dependency-Scanning.gitlab-ci.yml\n\ndependency_scanning:\n  stage: test\n  variables:\n    DS_PYTHON_VERSION: 3\n    DS_EXCLUDED_PATHS: 'test,docs'\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n  allow_failure: false",
    "usage": "1. Add this to your .gitlab-ci.yml file\n2. GitLab will automatically detect your project type\n3. Results appear in the Security & Compliance dashboard\n4. Configure excluded paths for better performance",
    "tags": ["Dependency Scanning", "GitLab CI", "SAST", "Security"],
    "language": "yaml"
  },
  {
    "id": "jenkins-pipeline-security",
    "title": "Jenkins Security Pipeline",
    "description": "Complete Jenkins pipeline with integrated security scanning stages including SAST, SCA, and container scanning.",
    "category": "Jenkins Pipelines",
    "code": "pipeline {\n    agent any\n    \n    tools {\n        maven 'Maven 3.8.1'\n        nodejs 'NodeJS 16'\n    }\n    \n    stages {\n        stage('Checkout') {\n            steps {\n                checkout scm\n            }\n        }\n        \n        stage('SAST - SonarQube') {\n            steps {\n                withSonarQubeEnv('My SonarQube Server') {\n                    sh 'mvn sonar:sonar'\n                }\n            }\n        }\n        \n        stage('SCA - Dependency Check') {\n            steps {\n                dependencyCheck additionalArguments: '--scan .', odcInstallation: 'dependency-check'\n                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'\n            }\n        }\n        \n        stage('Build Docker Image') {\n            steps {\n                script {\n                    docker.build(\"myapp:${env.BUILD_ID}\")\n                }\n            }\n        }\n        \n        stage('Container Security Scan') {\n            steps {\n                sh 'trivy image --exit-code 1 --severity HIGH,CRITICAL myapp:${env.BUILD_ID}'\n            }\n        }\n        \n        stage('Deploy') {\n            when {\n                branch 'main'\n            }\n            steps {\n                sh 'kubectl set image deployment/myapp myapp=myapp:${env.BUILD_ID}'\n            }\n        }\n    }\n    \n    post {\n        always {\n            publishHTML(target: [\n                allowMissing: false,\n                alwaysLinkToLastBuild: true,\n                keepAll: true,\n                reportDir: 'target/dependency-check-report',\n                reportFiles: 'index.html',\n                reportName: 'Dependency Check Report'\n            ])\n        }\n    }\n}",
    "usage": "1. Install required Jenkins plugins (SonarQube, Dependency-Check, HTML Publisher)\n2. Configure SonarQube server in Jenkins global settings\n3. Adjust tool versions according to your environment\n4. Modify deployment stage for your specific infrastructure",
    "tags": ["Jenkins", "Pipeline", "SAST", "SCA", "Container Security"],
    "language": "groovy"
  },
  {
    "id": "docker-security-config",
    "title": "Secure Docker Configuration",
    "description": "Dockerfile with security best practices including non-root user, multi-stage build, and security scanning.",
    "category": "Docker Security Configurations",
    "code": "# Multi-stage build for security and size optimization\nFROM node:18-alpine AS builder\n\n# Install build dependencies\nRUN apk add --no-cache python3 make g++\n\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\nRUN npm run build\n\n# Production stage with security hardening\nFROM node:18-alpine AS production\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs && \\\n    adduser -S nextjs -u 1001\n\n# Install security updates and minimal packages\nRUN apk update && apk upgrade && apk add --no-cache dumb-init\n\nWORKDIR /app\n\n# Copy built application\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY package.json .\n\n# Drop root privileges\nUSER nextjs\n\n# Security headers\nENV NODE_ENV=production\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD node healthcheck.js\n\n# Use init system to handle signals properly\nENTRYPOINT [\"dumb-init\", \"--\"]\nCMD [\"node\", \"dist/server.js\"]",
    "usage": "1. Replace the application-specific parts with your code\n2. Ensure healthcheck.js exists in your project\n3. Scan the built image with Trivy or similar tools\n4. Consider adding security scanning to your CI pipeline",
    "tags": ["Docker", "Security", "Multi-stage Build", "Non-root User"],
    "language": "dockerfile"
  },
  {
    "id": "kubernetes-network-policy",
    "title": "Kubernetes Network Security Policy",
    "description": "Kubernetes NetworkPolicy to restrict pod-to-pod communication and enhance cluster security.",
    "category": "Kubernetes Security Policies",
    "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: api-security-policy\n  namespace: production\nspec:\n  podSelector:\n    matchLabels:\n      app: api-server\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  # Allow traffic from frontend pods only\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - protocol: TCP\n      port: 8080\n  # Allow health checks from kubelet\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: kube-system\n    ports:\n    - protocol: TCP\n      port: 8080\n  egress:\n  # Allow DNS resolution\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: kube-system\n    ports:\n    - protocol: UDP\n      port: 53\n    - protocol: TCP\n      port: 53\n  # Allow database connections\n  - to:\n    - podSelector:\n        matchLabels:\n          app: database\n    ports:\n    - protocol: TCP\n      port: 5432",
    "usage": "1. Apply to your namespace with kubectl apply -f network-policy.yaml\n2. Test connectivity before applying to production\n3. Gradually tighten policies based on application requirements\n4. Monitor for blocked legitimate traffic",
    "tags": ["Kubernetes", "NetworkPolicy", "Security", "Microsegmentation"],
    "language": "yaml"
  },
  {
    "id": "terraform-aws-security",
    "title": "AWS Security Module with Terraform",
    "description": "Terraform module implementing AWS security best practices including VPC, security groups, and IAM policies.",
    "category": "Terraform Security Modules",
    "code": "# main.tf\nmodule \"vpc\" {\n  source = \"terraform-aws-modules/vpc/aws\"\n  \n  name = \"secure-vpc\"\n  cidr = \"10.0.0.0/16\"\n  \n  azs             = [\"us-west-2a\", \"us-west-2b\", \"us-west-2c\"]\n  private_subnets = [\"10.0.1.0/24\", \"10.0.2.0/24\", \"10.0.3.0/24\"]\n  public_subnets  = [\"10.0.101.0/24\", \"10.0.102.0/24\", \"10.0.103.0/24\"]\n  \n  enable_nat_gateway = true\n  single_nat_gateway = false\n  \n  # Security features\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n}\n\n# Security Groups\nresource \"aws_security_group\" \"web_sg\" {\n  name_prefix = \"web-sg\"\n  description = \"Security group for web servers\"\n  vpc_id      = module.vpc.vpc_id\n  \n  ingress {\n    description = \"HTTPS from internet\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  ingress {\n    description = \"HTTP redirect to HTTPS\"\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  tags = {\n    Name = \"web-security-group\"\n  }\n}\n\n# IAM Role with least privilege\nresource \"aws_iam_role\" \"ec2_role\" {\n  name = \"ec2-role\"\n  \n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ec2.amazonaws.com\"\n        }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"ec2_policy\" {\n  name = \"ec2-policy\"\n  role = aws_iam_role.ec2_role.id\n  \n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"s3:GetObject\",\n          \"s3:ListBucket\"\n        ]\n        Resource = [\n          \"arn:aws:s3:::my-app-bucket/*\",\n          \"arn:aws:s3:::my-app-bucket\"\n        ]\n      },\n      {\n        Effect = \"Allow\"\n        Action = [\n          \"logs:CreateLogGroup\",\n          \"logs:CreateLogStream\",\n          \"logs:PutLogEvents\"\n        ]\n        Resource = \"arn:aws:logs:*:*:*\"\n      }\n    ]\n  })\n}",
    "usage": "1. Customize CIDR blocks and regions for your environment\n2. Review and adjust IAM policies for least privilege\n3. Test in staging before applying to production\n4. Regularly audit and update security policies",
    "tags": ["Terraform", "AWS", "Security", "IAM", "VPC"],
    "language": "hcl"
  },
  {
    "id": "pre-commit-secrets-hook",
    "title": "Pre-commit Hook for Secret Detection",
    "description": "Pre-commit configuration to detect secrets and sensitive information before commits are made.",
    "category": "Pre-commit Hooks",
    "code": "# .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n      - id: check-added-large-files\n      - id: check-case-conflict\n      - id: check-json\n      - id: check-merge-conflict\n      - id: check-symlinks\n      - id: check-yaml\n      - id: detect-private-key\n      - id: end-of-file-fixer\n      - id: mixed-line-ending\n      - id: trailing-whitespace\n  \n  - repo: https://github.com/Yelp/detect-secrets\n    rev: v1.4.0\n    hooks:\n      - id: detect-secrets\n        args: ['--baseline', '.secrets.baseline']\n        exclude: package.lock.json\n  \n  - repo: https://github.com/zricethezav/gitleaks\n    rev: v8.16.1\n    hooks:\n      - id: gitleaks\n        args: [--verbose]\n  \n  - repo: local\n    hooks:\n      - id: custom-secret-check\n        name: Custom Secret Patterns\n        entry: ./.hooks/check-secrets.sh\n        language: script\n        types: [text]\n        exclude: >\n          (?x)^(.*/)?(\n            package-lock.json|\n            yarn.lock|\n            Gemfile.lock|\n            go.sum|\n            .secrets.baseline\n          )$",
    "usage": "1. Install pre-commit: pip install pre-commit\n2. Create .pre-commit-config.yaml with this content\n3. Run pre-commit install to set up the hooks\n4. Run pre-commit run --all-files to scan existing files\n5. Generate baseline: detect-secrets scan > .secrets.baseline",
    "tags": ["Pre-commit", "Secrets Detection", "Git Hooks", "Security"],
    "language": "yaml"
  },
  {
    "id": "github-sbom-generation",
    "title": "SBOM Generation Workflow",
    "description": "GitHub Actions workflow to automatically generate Software Bill of Materials using Syft and upload to dependency graph.",
    "category": "GitHub Actions Workflows",
    "code": "name: Generate SBOM\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  sbom:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n    \n    - name: Set up Syft\n      uses: anchore/sbom-action/download-syft@v0.14.1\n    \n    - name: Generate SBOM\n      run: |\n        syft ${{ github.event.repository.name }}:${{ github.sha }} \\\n          -o spdx-json \\\n          --file sbom.spdx.json\n    \n    - name: Upload SBOM as artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: sbom\n        path: sbom.spdx.json\n    \n    - name: Upload to Dependency Graph\n      if: github.event_name == 'push'\n      uses: advanced-security/spdx-dependency-submission-action@v0.1.0\n      with:\n        filePath: sbom.spdx.json",
    "usage": "1. Add this workflow to .github/workflows/sbom.yml\n2. The workflow generates SPDX-formatted SBOM\n3. SBOM is uploaded to GitHub's dependency graph\n4. Available in repository's Insights > Dependencies tab",
    "tags": ["SBOM", "Syft", "SPDX", "Dependency Graph", "Supply Chain Security"],
    "language": "yaml"
  },
  {
    "id": "terraform-security-linting",
    "title": "Terraform Security Linting Pipeline",
    "description": "CI pipeline configuration for Terraform security scanning using Checkov and TFLint.",
    "category": "GitLab CI Templates",
    "code": "stages:\n  - validate\n  - security\n  - plan\n  - deploy\n\nvariables:\n  TF_ROOT: ${CI_PROJECT_DIR}/terraform\n  TF_STATE_NAME: ${CI_PROJECT_NAME}\n\nbefore_script:\n  - cd ${TF_ROOT}\n  - terraform version\n  - terraform init -backend-config=backend.conf\n\ntflint:\n  stage: validate\n  image:\n    name: ghcr.io/terraform-linters/tflint\n    entrypoint: [\"\"]\n  script:\n    - tflint --init\n    - tflint -f compact\n  allow_failure: false\n\ncheckov:\n  stage: security\n  image:\n    name: bridgecrew/checkov:latest\n  script:\n    - checkov -d . --quiet --skip-check CKV_AWS_123,CKV_GCP_123\n  artifacts:\n    reports:\n      cobertura: checkov-report.xml\n  allow_failure: false\n\nterraform_validate:\n  stage: validate\n  script:\n    - terraform validate\n  allow_failure: false\n\nterraform_plan:\n  stage: plan\n  script:\n    - terraform plan -out=tfplan\n    - terraform show -json tfplan > tfplan.json\n  artifacts:\n    paths:\n      - ${TF_ROOT}/tfplan\n      - ${TF_ROOT}/tfplan.json\n    expire_in: 1 week\n  only:\n    - merge_requests\n\nterraform_apply:\n  stage: deploy\n  script:\n    - terraform apply -auto-approve tfplan\n  when: manual\n  only:\n    - main",
    "usage": "1. Place in .gitlab-ci.yml in your repository\n2. Create backend.conf for remote state configuration\n3. Adjust skip-check codes based on your organization's policies\n4. Review Checkov findings before applying Terraform changes",
    "tags": ["Terraform", "Checkov", "TFLint", "Infrastructure Security"],
    "language": "yaml"
  },
  {
    "id": "docker-compose-security",
    "title": "Secure Docker Compose Configuration",
    "description": "Docker Compose file with security configurations for multi-service applications.",
    "category": "Docker Security Configurations",
    "code": "version: '3.8'\n\nservices:\n  web:\n    build:\n      context: ./web\n      dockerfile: Dockerfile.prod\n    ports:\n      - \"127.0.0.1:3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://user:password@db:5432/myapp\n    networks:\n      - frontend\n      - backend\n    volumes:\n      - ./logs:/app/logs:rw\n    security_opt:\n      - no-new-privileges:true\n    read_only: true\n    tmpfs:\n      - /tmp\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n\n  db:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: myapp\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD_FILE: /run/secrets/db_password\n    volumes:\n      - db_data:/var/lib/postgresql/data\n      - ./init-scripts:/docker-entrypoint-initdb.d:ro\n    networks:\n      - backend\n    secrets:\n      - db_password\n    read_only: true\n    tmpfs:\n      - /tmp\n      - /var/run/postgresql\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U user -d myapp\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n      - ./ssl:/etc/nginx/ssl:ro\n    networks:\n      - frontend\n    depends_on:\n      - web\n    read_only: true\n    tmpfs:\n      - /var/cache/nginx\n      - /var/run\n    cap_drop:\n      - ALL\n    cap_add:\n      - CHOWN\n      - SETGID\n      - SETUID\n    restart: unless-stopped\n\nnetworks:\n  frontend:\n    driver: bridge\n  backend:\n    driver: bridge\n    internal: true\n\nvolumes:\n  db_data:\n\nsecrets:\n  db_password:\n    file: ./secrets/db_password.txt",
    "usage": "1. Create separate secret files for sensitive data\n2. Use read-only volumes where possible\n3. Implement network segmentation with internal networks\n4. Configure proper health checks for all services",
    "tags": ["Docker Compose", "Security", "Multi-service", "Network Segmentation"],
    "language": "yaml"
  },
  {
    "id": "kubernetes-rbac-policy",
    "title": "Kubernetes RBAC Security Policy",
    "description": "Kubernetes Role-Based Access Control configuration for least privilege principle implementation.",
    "category": "Kubernetes Security Policies",
    "code": "apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: production\n  name: deployment-manager\nrules:\n- apiGroups: [\"apps\"]\n  resources: [\"deployments\"]\n  verbs: [\"get\", \"list\", \"watch\", \"update\", \"patch\"]\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n- apiGroups: [\"\"]\n  resources: [\"configmaps\"]\n  verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: deployment-manager-binding\n  namespace: production\nsubjects:\n- kind: User\n  name: developer@example.com\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: deployment-manager\n  apiGroup: rbac.authorization.k8s.io\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: monitoring-viewer\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"services\", \"endpoints\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n- apiGroups: [\"metrics.k8s.io\"]\n  resources: [\"pods\", \"nodes\"]\n  verbs: [\"get\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: monitoring-viewer-binding\nsubjects:\n- kind: ServiceAccount\n  name: monitoring-sa\n  namespace: monitoring\nroleRef:\n  kind: ClusterRole\n  name: monitoring-viewer\n  apiGroup: rbac.authorization.k8s.io\n---\n# Pod Security Standards\napiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: restricted-psp\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  requiredDropCapabilities:\n    - ALL\n  volumes:\n    - 'configMap'\n    - 'emptyDir'\n    - 'projected'\n    - 'secret'\n    - 'downwardAPI'\n    - 'persistentVolumeClaim'\n  hostNetwork: false\n  hostIPC: false\n  hostPID: false\n  runAsUser:\n    rule: 'MustRunAsNonRoot'\n  seLinux:\n    rule: 'RunAsAny'\n  supplementalGroups:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  fsGroup:\n    rule: 'MustRunAs'\n    ranges:\n      - min: 1\n        max: 65535\n  readOnlyRootFilesystem: true",
    "usage": "1. Apply RBAC policies gradually, testing permissions\n2. Use namespaces to isolate different environments\n3. Regularly audit and rotate service account tokens\n4. Implement the principle of least privilege",
    "tags": ["Kubernetes", "RBAC", "Security", "Least Privilege"],
    "language": "yaml"
  },
  {
    "id": "jenkins-security-hardening",
    "title": "Jenkins Security Hardening Pipeline",
    "description": "Jenkins pipeline with security hardening measures including credential management and security scanning.",
    "category": "Jenkins Pipelines",
    "code": "pipeline {\n    agent any\n    \n    environment {\n        SCAN_ON_FAILURE = 'true'\n        SECURITY_SCAN_TOOL = 'trivy'\n    }\n    \n    stages {\n        stage('Security Preparation') {\n            steps {\n                script {\n                    // Mask sensitive variables\n                    sh 'echo \"***MASKED***\"'\n                }\n            }\n        }\n        \n        stage('Code Checkout with Security') {\n            steps {\n                git branch: 'main',\n                    url: 'https://github.com/example/repo.git',\n                    credentialsId: 'github-credentials'\n            }\n        }\n        \n        stage('Secrets Scanning') {\n            steps {\n                sh '''\n                # Scan for hardcoded secrets\n                gitleaks detect --report-format json --report-path gitleaks-report.json || true\n                \n                # Check for secrets in code\n                if [ -f \"gitleaks-report.json\" ] && [ \"$(jq length gitleaks-report.json)\" -gt 0 ]; then\n                    echo \"SECRETS FOUND! Pipeline will fail.\"\n                    cat gitleaks-report.json\n                    exit 1\n                fi\n                '''\n            }\n        }\n        \n        stage('Dependency Vulnerability Scan') {\n            steps {\n                sh '''\n                # Scan dependencies for vulnerabilities\n                case \"${LANGUAGE}\" in\n                    \"node\")\n                        npm audit --audit-level=high\n                        ;;\n                    \"python\")\n                        pip-audit --requirement requirements.txt\n                        ;;\n                    \"java\")\n                        mvn dependency-check:check\n                        ;;\n                esac\n                '''\n            }\n        }\n        \n        stage('Container Security Scan') {\n            steps {\n                script {\n                    docker.image('aquasec/trivy:latest').inside {\n                        sh '''\n                        trivy fs --exit-code 1 --severity HIGH,CRITICAL . || true\n                        trivy image --exit-code 1 --severity HIGH,CRITICAL myapp:latest || true\n                        '''\n                    }\n                }\n            }\n        }\n        \n        stage('Security Gate') {\n            steps {\n                script {\n                    // Fail pipeline if security issues found\n                    def securityIssues = sh(script: 'find . -name \"*.sarif\" -o -name \"*-report.json\" | wc -l', returnStdout: true).trim()\n                    if (securityIssues.toInteger() > 0) {\n                        echo \"Security issues detected. Check reports for details.\"\n                        archiveArtifacts artifacts: '**/*-report.*', fingerprint: true\n                        if (env.SCAN_ON_FAILURE == 'true') {\n                            currentBuild.result = 'UNSTABLE'\n                        } else {\n                            error 'Security scan failed'\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    post {\n        always {\n            // Archive security reports\n            archiveArtifacts artifacts: [\n                '**/gitleaks-report.json',\n                '**/*dependency-check-report.xml',\n                '**/trivy-results.sarif'\n            ].join(','),\n            fingerprint: true,\n            allowEmptyArchive: true\n        }\n        \n        failure {\n            // Send security alerts\n            mail to: 'security-team@example.com',\n                 subject: \"Security Pipeline Failed - ${env.JOB_NAME}\",\n                 body: \"Security scan failed in job ${env.JOB_NAME} build ${env.BUILD_NUMBER}\"\n        }\n    }\n}",
    "usage": "1. Install required Jenkins plugins (Credentials Binding, Workspace Cleanup)\n2. Configure credentials in Jenkins credential store\n3. Adjust security thresholds based on your organization's risk tolerance\n4. Set up notification channels for security alerts",
    "tags": ["Jenkins", "Security Hardening", "Secrets Scanning", "Vulnerability Management"],
    "language": "groovy"
  },
  {
    "id": "github-security-gate",
    "title": "Security Gate Implementation",
    "description": "GitHub Actions workflow implementing security gates to prevent merging code with critical vulnerabilities.",
    "category": "GitHub Actions Workflows",
    "code": "name: Security Gate\n\non:\n  pull_request:\n    branches: [ main, develop ]\n    types: [ opened, synchronize, reopened ]\n\njobs:\n  security-gate:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n      security-events: write\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n      with:\n        fetch-depth: 0\n    \n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n    \n    - name: Install dependencies\n      run: npm ci\n    \n    - name: Run security audit\n      run: |\n        # Fail on high and critical vulnerabilities\n        npm audit --audit-level=high\n      continue-on-error: false\n    \n    - name: SAST Scan\n      uses: github/codeql-action/analyze@v3\n      with:\n        category: \"/language:javascript\"\n    \n    - name: Dependency Scanning\n      uses: snyk/actions/node@master\n      env:\n        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n      with:\n        args: --severity-threshold=high --fail-on=all\n    \n    - name: Secret Scanning\n      uses: gitleaks/gitleaks-action@v2\n      with:\n        config-path: .gitleaks.toml\n    \n    - name: Container Scanning (if Dockerfile exists)\n      if: hashFiles('Dockerfile') != ''\n      run: |\n        docker build -t app:test .\n        docker run --rm aquasec/trivy image --exit-code 1 --severity HIGH,CRITICAL app:test\n    \n    - name: Check for security policy compliance\n      run: |\n        # Custom security checks\n        if [ ! -f \"SECURITY.md\" ]; then\n          echo \"ERROR: SECURITY.md file is missing\"\n          exit 1\n        fi\n        \n        # Check for security headers in package.json\n        if ! jq -e '.scripts.\"security-check\"' package.json >/dev/null 2>&1; then\n          echo \"WARNING: No security-check script found in package.json\"\n        fi\n    \n    - name: Comment on PR if vulnerabilities found\n      if: failure()\n      uses: actions/github-script@v7\n      with:\n        script: |\n          github.rest.issues.createComment({\n            issue_number: context.issue.number,\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            body: 'ðŸš¨ **Security Gate Failed**\\n\\nCritical security issues were detected. Please address the following:\\n\\n1. Run `npm audit fix` to fix dependency vulnerabilities\\n2. Check CodeQL results in the Security tab\\n3. Review Snyk scan results\\n4. Remove any hardcoded secrets\\n\\nThis PR cannot be merged until security issues are resolved.'\n          })\n    \n    - name: Block merge on security failures\n      if: failure()\n      run: |\n        echo \"Security gate failed. Blocking merge.\"\n        exit 1",
    "usage": "1. Add this workflow to .github/workflows/security-gate.yml\n2. Create .gitleaks.toml for custom secret patterns\n3. Add SNYK_TOKEN secret in GitHub repository settings\n4. Configure branch protection rules to require this check",
    "tags": ["Security Gate", "GitHub Actions", "Merge Protection", "Vulnerability Management"],
    "language": "yaml"
  }
]